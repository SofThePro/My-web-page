<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Minesweeper</title>
  <style>
    :root{
      --bg:#0f1220;
      --panel:#171a2b;
      --tile:#222641;
      --tile2:#1b1f36;
      --open:#2c3153;
      --border:#3a3f6b;
      --text:#e8ebff;
      --muted:#aab0d6;
      --good:#48d18b;
      --bad:#ff4d6d;
      --warn:#ffd166;
      --shadow: 0 10px 30px rgba(0,0,0,.35);
      --radius: 14px;
      --font: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji";
    }
    *{box-sizing:border-box}
    body{
      margin:0;
      font-family:var(--font);
      background: radial-gradient(1200px 600px at 20% 0%, #1a1f3b 0%, var(--bg) 55%);
      color:var(--text);
      min-height:100vh;
      display:flex;
      align-items:center;
      justify-content:center;
      padding:24px;
    }
    .app{
      width:min(980px, 100%);
      display:grid;
      gap:14px;
      grid-template-columns: 330px 1fr;
    }
    @media (max-width: 900px){
      .app{grid-template-columns: 1fr}
    }
    .card{
      background: linear-gradient(180deg, rgba(255,255,255,.05), rgba(255,255,255,.02));
      border: 1px solid rgba(255,255,255,.08);
      box-shadow: var(--shadow);
      border-radius: var(--radius);
      overflow:hidden;
    }
    .sidebar{padding:16px}
    h1{
      margin:0 0 10px;
      font-size:22px;
      letter-spacing:.3px;
    }
    .row{display:flex; gap:10px; align-items:center; flex-wrap:wrap}
    label{
      font-size:12px;
      color:var(--muted);
      display:block;
      margin:10px 0 6px;
    }
    select, input, button{
      font:inherit;
      color:var(--text);
    }
    select, input[type="number"]{
      width:100%;
      padding:10px 12px;
      border-radius:12px;
      border:1px solid rgba(255,255,255,.12);
      background: rgba(0,0,0,.18);
      outline:none;
    }
    input[type="number"]{appearance:textfield}
    .btn{
      cursor:pointer;
      padding:10px 12px;
      border-radius:12px;
      border:1px solid rgba(255,255,255,.12);
      background: rgba(255,255,255,.06);
      transition: transform .05s ease, background .2s ease;
      user-select:none;
    }
    .btn:hover{background: rgba(255,255,255,.10)}
    .btn:active{transform: translateY(1px)}
    .btn.primary{
      background: rgba(72, 209, 139, .18);
      border-color: rgba(72, 209, 139, .35);
    }
    .btn.danger{
      background: rgba(255, 77, 109, .16);
      border-color: rgba(255, 77, 109, .35);
    }
    .stats{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap:10px;
      margin-top:12px;
    }
    .stat{
      padding:10px 12px;
      border-radius:12px;
      background: rgba(0,0,0,.16);
      border: 1px solid rgba(255,255,255,.10);
    }
    .stat .k{font-size:12px; color:var(--muted)}
    .stat .v{font-size:18px; margin-top:2px}
    .help{
      margin-top:12px;
      font-size:13px;
      color:var(--muted);
      line-height:1.35;
    }
    .help kbd{
      font-size:12px;
      padding:2px 6px;
      border-radius:8px;
      border:1px solid rgba(255,255,255,.12);
      background: rgba(0,0,0,.20);
      color:var(--text);
    }
    .boardWrap{
      display:flex;
      align-items:center;
      justify-content:center;
      padding:16px;
    }
    .topbar{
      padding:12px 14px;
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:12px;
      border-bottom: 1px solid rgba(255,255,255,.08);
      background: rgba(0,0,0,.12);
    }
    .status{
      display:flex;
      align-items:center;
      gap:10px;
      flex-wrap:wrap;
      font-size:13px;
      color:var(--muted);
    }
    .pill{
      padding:6px 10px;
      border-radius:999px;
      background: rgba(0,0,0,.18);
      border: 1px solid rgba(255,255,255,.10);
      color: var(--text);
      font-size:12px;
    }

    /* Board grid */
    .board{
      --cell: 28px;
      display:grid;
      gap:4px;
      padding:12px;
      background: rgba(0,0,0,.14);
      border: 1px solid rgba(255,255,255,.08);
      border-radius: 16px;
      overflow:auto;
      max-width: 100%;
      max-height: 76vh;
    }
    @media (max-width: 500px){
      .board{--cell: 26px}
    }
    .cell{
      width: var(--cell);
      height: var(--cell);
      border-radius: 9px;
      display:flex;
      align-items:center;
      justify-content:center;
      cursor:pointer;
      user-select:none;
      background: linear-gradient(180deg, rgba(255,255,255,.06), rgba(0,0,0,.05));
      border:1px solid rgba(255,255,255,.10);
      color: var(--text);
      font-weight: 700;
      font-size: 14px;
      text-shadow: 0 1px 0 rgba(0,0,0,.25);
    }
    .cell:hover{filter: brightness(1.08)}
    .cell.open{
      cursor:default;
      background: rgba(255,255,255,.07);
      border-color: rgba(255,255,255,.14);
    }
    .cell.flag{
      background: rgba(255, 209, 102, .10);
      border-color: rgba(255, 209, 102, .35);
    }
    .cell.mine{
      background: rgba(255, 77, 109, .16);
      border-color: rgba(255, 77, 109, .45);
    }
    .cell.boom{
      background: rgba(255, 77, 109, .28);
      border-color: rgba(255, 77, 109, .85);
      transform: scale(1.03);
    }

    /* number colors */
    .n1{color:#6ea8fe}
    .n2{color:#63e6be}
    .n3{color:#ff8787}
    .n4{color:#b197fc}
    .n5{color:#ffa94d}
    .n6{color:#66d9e8}
    .n7{color:#ced4da}
    .n8{color:#ffd43b}

    .footerBtns{display:flex; gap:10px; margin-top:12px}
    .footerBtns .btn{flex:1}
  </style>
</head>
<body>
  <div class="app">
    <div class="card sidebar">
      <h1>ðŸ’£ Minesweeper</h1>

      <label for="preset">Difficulty</label>
      <select id="preset">
        <option value="beginner">Beginner (9Ã—9, 10 mines)</option>
        <option value="intermediate">Intermediate (16Ã—16, 40 mines)</option>
        <option value="expert">Expert (30Ã—16, 99 mines)</option>
        <option value="custom">Custom</option>
      </select>

      <div class="row">
        <div style="flex:1; min-width: 90px;">
          <label for="w">Width</label>
          <input id="w" type="number" min="5" max="50" value="9" />
        </div>
        <div style="flex:1; min-width: 90px;">
          <label for="h">Height</label>
          <input id="h" type="number" min="5" max="35" value="9" />
        </div>
        <div style="flex:1; min-width: 100px;">
          <label for="m">Mines</label>
          <input id="m" type="number" min="1" max="500" value="10" />
        </div>
      </div>

      <div class="stats">
        <div class="stat">
          <div class="k">Mines left</div>
          <div class="v" id="minesLeft">10</div>
        </div>
        <div class="stat">
          <div class="k">Time</div>
          <div class="v"><span id="time">0</span>s</div>
        </div>
      </div>

      <div class="footerBtns">
        <button class="btn primary" id="newBtn">New game</button>
        <button class="btn" id="revealBtn" title="Reveals the board (cheat)">Reveal</button>
      </div>

      <div class="help">
        <p>
          <strong>How to play:</strong><br/>
          Left click = open<br/>
          Right click = flag/unflag<br/>
          Middle click or <kbd>Shift</kbd>+click on an opened number = chord (open neighbors when flags match)
        </p>
        <p>
          First click is always safe.
        </p>
      </div>
    </div>

    <div class="card">
      <div class="topbar">
        <div class="status">
          <span class="pill" id="statePill">Ready</span>
          <span class="pill" id="sizePill">9Ã—9</span>
          <span class="pill" id="minePill">10 mines</span>
        </div>
        <button class="btn danger" id="resetBtn">Reset</button>
      </div>
      <div class="boardWrap">
        <div id="board" class="board" aria-label="Minesweeper board"></div>
      </div>
    </div>
  </div>

<script>
(() => {
  const boardEl = document.getElementById("board");
  const minesLeftEl = document.getElementById("minesLeft");
  const timeEl = document.getElementById("time");
  const statePill = document.getElementById("statePill");
  const sizePill = document.getElementById("sizePill");
  const minePill = document.getElementById("minePill");

  const presetEl = document.getElementById("preset");
  const wEl = document.getElementById("w");
  const hEl = document.getElementById("h");
  const mEl = document.getElementById("m");

  const newBtn = document.getElementById("newBtn");
  const resetBtn = document.getElementById("resetBtn");
  const revealBtn = document.getElementById("revealBtn");

  const PRESETS = {
    beginner: { w: 9,  h: 9,  m: 10 },
    intermediate:{ w: 16, h: 16, m: 40 },
    expert: { w: 30, h: 16, m: 99 },
  };

  let W=9, H=9, MINES=10;
  let grid = []; // cell objects
  let firstClick = true;
  let gameOver = false;
  let openedCount = 0;
  let flagsCount = 0;

  let timer = null;
  let seconds = 0;

  function setStatus(text, kind){
    statePill.textContent = text;
    statePill.style.borderColor =
      kind === "win" ? "rgba(72,209,139,.55)" :
      kind === "lose" ? "rgba(255,77,109,.65)" :
      "rgba(255,255,255,.10)";
    statePill.style.background =
      kind === "win" ? "rgba(72,209,139,.14)" :
      kind === "lose" ? "rgba(255,77,109,.14)" :
      "rgba(0,0,0,.18)";
  }

  function clampInputs(){
    W = Math.max(5, Math.min(50, parseInt(wEl.value || "9", 10)));
    H = Math.max(5, Math.min(35, parseInt(hEl.value || "9", 10)));
    const maxM = W*H - 1;
    MINES = Math.max(1, Math.min(maxM, parseInt(mEl.value || "10", 10)));
    wEl.value = W; hEl.value = H; mEl.value = MINES;
  }

  function updatePills(){
    sizePill.textContent = `${W}Ã—${H}`;
    minePill.textContent = `${MINES} mines`;
  }

  function stopTimer(){
    if (timer){ clearInterval(timer); timer = null; }
  }
  function startTimer(){
    stopTimer();
    timer = setInterval(() => {
      seconds++;
      timeEl.textContent = seconds;
    }, 1000);
  }
  function resetTimer(){
    stopTimer();
    seconds = 0;
    timeEl.textContent = "0";
  }

  function idx(x,y){ return y*W + x; }
  function inBounds(x,y){ return x>=0 && x<W && y>=0 && y<H; }

  function neighbors(x,y){
    const out = [];
    for (let dy=-1; dy<=1; dy++){
      for (let dx=-1; dx<=1; dx++){
        if (dx===0 && dy===0) continue;
        const nx=x+dx, ny=y+dy;
        if (inBounds(nx,ny)) out.push([nx,ny]);
      }
    }
    return out;
  }

  function makeEmptyGrid(){
    grid = new Array(W*H).fill(0).map((_, i) => {
      const x = i % W, y = (i / W) | 0;
      return {
        x, y,
        mine: false,
        open: false,
        flag: false,
        adj: 0,
        el: null
      };
    });
  }

  // Place mines AFTER first click so first click is safe.
  // Also, we keep a 3x3 safe zone around the first click (classic friendly behavior).
  function placeMinesAvoiding(sx, sy){
    const forbidden = new Set();
    forbidden.add(idx(sx,sy));
    for (const [nx,ny] of neighbors(sx,sy)) forbidden.add(idx(nx,ny));

    const candidates = [];
    for (let i=0; i<grid.length; i++){
      if (!forbidden.has(i)) candidates.push(i);
    }

    // Fisher-Yates shuffle candidates
    for (let i=candidates.length-1; i>0; i--){
      const j = (Math.random() * (i+1)) | 0;
      [candidates[i], candidates[j]] = [candidates[j], candidates[i]];
    }

    const toPlace = Math.min(MINES, candidates.length);
    for (let k=0; k<toPlace; k++){
      grid[candidates[k]].mine = true;
    }

    // Compute adjacency
    for (const c of grid){
      if (c.mine) continue;
      let count = 0;
      for (const [nx,ny] of neighbors(c.x,c.y)){
        if (grid[idx(nx,ny)].mine) count++;
      }
      c.adj = count;
    }
  }

  function renderBoard(){
    boardEl.innerHTML = "";
    boardEl.style.gridTemplateColumns = `repeat(${W}, var(--cell))`;

    for (const c of grid){
      const d = document.createElement("div");
      d.className = "cell";
      d.setAttribute("role","button");
      d.setAttribute("aria-label", `Cell ${c.x+1},${c.y+1}`);
      d.oncontextmenu = (e) => e.preventDefault(); // disable menu
      d.addEventListener("mousedown", (e) => onMouseDown(e, c));
      d.addEventListener("click", (e) => onLeftClick(e, c));
      d.addEventListener("auxclick", (e) => onAuxClick(e, c)); // middle click
      c.el = d;
      boardEl.appendChild(d);
    }
  }

  function setCellText(c, text){
    c.el.textContent = text ?? "";
  }

  function paintCell(c){
    const el = c.el;
    el.classList.toggle("open", c.open);
    el.classList.toggle("flag", c.flag);
    el.classList.remove("mine", "boom");
    el.classList.remove("n1","n2","n3","n4","n5","n6","n7","n8");

    if (c.open){
      if (c.mine){
        el.classList.add("mine");
        setCellText(c, "ðŸ’£");
      } else if (c.adj > 0){
        el.classList.add("n"+c.adj);
        setCellText(c, String(c.adj));
      } else {
        setCellText(c, "");
      }
    } else {
      if (c.flag){
        setCellText(c, "ðŸš©");
      } else {
        setCellText(c, "");
      }
    }
  }

  function updateCounters(){
    minesLeftEl.textContent = String(Math.max(0, MINES - flagsCount));
  }

  function openCell(c){
    if (gameOver || c.open || c.flag) return;

    c.open = true;
    openedCount++;
    paintCell(c);

    if (c.mine){
      explodeAt(c);
      return;
    }

    // If zero, flood fill
    if (c.adj === 0){
      const stack = [[c.x,c.y]];
      const seen = new Set([idx(c.x,c.y)]);
      while (stack.length){
        const [x,y] = stack.pop();
        for (const [nx,ny] of neighbors(x,y)){
          const n = grid[idx(nx,ny)];
          if (n.open || n.flag) continue;
          if (n.mine) continue;
          n.open = true;
          openedCount++;
          paintCell(n);
          if (n.adj === 0){
            const key = idx(nx,ny);
            if (!seen.has(key)){
              seen.add(key);
              stack.push([nx,ny]);
            }
          }
        }
      }
    }

    checkWin();
  }

  function toggleFlag(c){
    if (gameOver || c.open) return;
    c.flag = !c.flag;
    flagsCount += c.flag ? 1 : -1;
    paintCell(c);
    updateCounters();
    checkWin(); // allow winning by flagging all mines if everything else open
  }

  function chordOpen(c){
    if (gameOver || !c.open || c.mine || c.adj === 0) return;

    // count flags around
    let f = 0;
    const neigh = neighbors(c.x,c.y);
    for (const [nx,ny] of neigh){
      if (grid[idx(nx,ny)].flag) f++;
    }
    if (f !== c.adj) return;

    // open non-flag neighbors
    for (const [nx,ny] of neigh){
      const n = grid[idx(nx,ny)];
      if (!n.flag && !n.open){
        openCell(n);
      }
    }
  }

  function explodeAt(c){
    gameOver = true;
    stopTimer();
    setStatus("Boom! ðŸ’¥", "lose");

    // show all mines
    for (const cell of grid){
      if (cell.mine){
        cell.open = true;
        paintCell(cell);
      }
    }
    c.el.classList.add("boom");
  }

  function revealAll(){
    for (const cell of grid){
      cell.open = true;
      paintCell(cell);
    }
  }

  function checkWin(){
    if (gameOver) return;
    const safeCells = W*H - MINES;
    if (openedCount >= safeCells){
      gameOver = true;
      stopTimer();
      setStatus("You win! ðŸŽ‰", "win");

      // auto-flag remaining mines for satisfaction
      for (const cell of grid){
        if (cell.mine && !cell.flag){
          cell.flag = true;
          flagsCount++;
          paintCell(cell);
        }
      }
      updateCounters();
    }
  }

  function onMouseDown(e, c){
    // Prevent middle-click scroll on some browsers
    if (e.button === 1) e.preventDefault();
  }

  function onLeftClick(e, c){
    if (gameOver) return;

    // Shift+click chord on open cell
    if (e.shiftKey && c.open){
      chordOpen(c);
      return;
    }

    if (c.flag) return;

    if (firstClick){
      firstClick = false;
      placeMinesAvoiding(c.x, c.y);
      startTimer();
      setStatus("Playing", "play");
      // Paint adjacency numbers for any already-open cell (none yet)
    }

    openCell(c);
  }

  function onAuxClick(e, c){
    // Middle click for chord
    if (e.button === 1){
      chordOpen(c);
    }
  }

  // Right-click flagging
  boardEl.addEventListener("contextmenu", (e) => {
    e.preventDefault();
    const target = e.target.closest(".cell");
    if (!target) return;
    const i = Array.prototype.indexOf.call(boardEl.children, target);
    if (i < 0) return;
    toggleFlag(grid[i]);
  });

  function newGame(){
    clampInputs();
    updatePills();

    firstClick = true;
    gameOver = false;
    openedCount = 0;
    flagsCount = 0;

    resetTimer();
    setStatus("Ready", "ready");

    makeEmptyGrid();
    renderBoard();
    updateCounters();
  }

  function resetGame(){
    // Same settings, fresh grid
    newGame();
  }

  presetEl.addEventListener("change", () => {
    const v = presetEl.value;
    if (v === "custom") {
      // keep current values
    } else {
      const p = PRESETS[v];
      wEl.value = p.w; hEl.value = p.h; mEl.value = p.m;
    }
    newGame();
  });

  [wEl, hEl, mEl].forEach(el => el.addEventListener("change", () => {
    presetEl.value = "custom";
    newGame();
  }));

  newBtn.addEventListener("click", newGame);
  resetBtn.addEventListener("click", resetGame);
  revealBtn.addEventListener("click", () => {
    if (firstClick){
      // If reveal before first click, place mines arbitrarily (no safe zone needed)
      firstClick = false;
      placeMinesAvoiding(0,0);
      setStatus("Revealed (cheat)", "play");
    }
    revealAll();
  });

  // Start
  newGame();
})();
</script>
</body>
</html>