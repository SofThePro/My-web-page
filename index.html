<!doctype html>
<html lang="no">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Snake ‚Äì HTML/Canvas</title>
  <style>
    :root {
      --bg: #0b1020;
      --panel: #131a2a;
      --accent: #5eead4;
      --accent-2: #a78bfa;
      --text: #e5e7eb;
      --muted: #9ca3af;
      --danger: #ef4444;
    }
    * { box-sizing: border-box; }
    html, body {
      height: 100%;
      margin: 0;
      background: radial-gradient(1200px 800px at 70% 20%, #121a33 0%, var(--bg) 50%, #060914 100%);
      color: var(--text);
      font: 16px/1.5 system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, "Helvetica Neue", Arial, "Apple Color Emoji", "Segoe UI Emoji";
    }
    .wrap {
      max-width: 1000px;
      margin: 0 auto;
      padding: 24px;
      display: grid;
      grid-template-columns: 1fr 300px;
      gap: 24px;
    }
    @media (max-width: 900px) {
      .wrap { grid-template-columns: 1fr; }
    }
    .card {
      background: linear-gradient(180deg, rgba(255,255,255,0.03), rgba(255,255,255,0.01));
      border: 1px solid rgba(255,255,255,0.08);
      border-radius: 16px;
      box-shadow: 0 12px 30px rgba(0,0,0,0.35);
    }
    header.card {
      padding: 18px 20px;
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 12px;
    }
    header h1 { font-size: 20px; margin: 0; letter-spacing: 0.4px; }
    .badges { display: flex; gap: 8px; align-items: center; }
    .badge {
      background: rgba(255,255,255,0.06);
      border: 1px solid rgba(255,255,255,0.12);
      padding: 6px 10px;
      border-radius: 999px;
      font-size: 12px;
      color: var(--muted);
    }
    .game.card { padding: 16px; display: grid; place-items: center; }
    canvas { width: 100%; height: auto; max-width: 680px; background: #0e1426; border-radius: 12px; border: 1px solid rgba(255,255,255,0.08); image-rendering: pixelated; }

    .panel.card { padding: 16px; }
    .row { display: flex; align-items: center; justify-content: space-between; gap: 8px; margin-bottom: 10px; }
    .row .label { color: var(--muted); font-size: 13px; }
    .score { font-weight: 700; font-size: 18px; }
    .controls { display: grid; grid-template-columns: repeat(3, 1fr); gap: 10px; margin-top: 14px; }
    button {
      background: rgba(255,255,255,0.06);
      border: 1px solid rgba(255,255,255,0.14);
      color: var(--text);
      border-radius: 12px;
      padding: 10px 12px;
      font-weight: 600; letter-spacing: .2px;
      cursor: pointer;
      transition: transform .08s ease, background .2s ease, border-color .2s ease;
    }
    button:hover { transform: translateY(-1px); }
    button:active { transform: translateY(0); }
    button.primary { background: linear-gradient(180deg, rgba(94,234,212,.15), rgba(94,234,212,.05)); border-color: rgba(94,234,212,.35); }
    button.alt { background: linear-gradient(180deg, rgba(167,139,250,.15), rgba(167,139,250,.05)); border-color: rgba(167,139,250,.35); }
    button.danger { background: linear-gradient(180deg, rgba(239,68,68,.15), rgba(239,68,68,.05)); border-color: rgba(239,68,68,.35); }

    .touch {
      display: none;
      margin-top: 16px;
      user-select: none;
    }
    .pad { display: grid; grid-template-columns: 70px 70px 70px; grid-template-rows: 70px 70px 70px; gap: 10px; place-content: center; margin: 0 auto; }
    .pad button { width: 70px; height: 70px; border-radius: 16px; font-size: 18px; }
    .pad .empty { visibility: hidden; }

    @media (max-width: 900px) {
      .touch { display: block; }
    }
    footer { text-align: center; margin-top: 16px; color: var(--muted); font-size: 12px; }
  </style>
</head>
<body>
  <div class="wrap">
    <header class="card">
      <h1>üêç Snake</h1>
      <div class="badges">
        <span class="badge">Piltaster / WASD</span>
        <span class="badge">Mellomrom = Pause</span>
      </div>
    </header>

    <section class="game card">
      <canvas id="board" width="680" height="480" aria-label="Snake spillbrett"></canvas>
    </section>

    <aside class="panel card">
      <div class="row"><span class="label">Poeng</span><span id="score" class="score">0</span></div>
      <div class="row"><span class="label">Rekord</span><span id="hiscore" class="score">0</span></div>
      <div class="row"><span class="label">Hastighet</span><span id="speedval">1x</span></div>
      <div class="controls">
        <button id="startBtn" class="primary">Start</button>
        <button id="pauseBtn" class="alt">Pause</button>
        <button id="resetBtn" class="danger">Reset</button>
        <button id="slowerBtn">‚àí Saktere</button>
        <button id="fasterBtn">Raskere +</button>
        <button id="wrapBtn">Vegger: P√•</button>
      </div>

      <div class="touch">
        <div class="pad">
          <div class="empty"></div>
          <button data-dir="up">‚¨ÜÔ∏è</button>
          <div class="empty"></div>
          <button data-dir="left">‚¨ÖÔ∏è</button>
          <button id="touchPause">‚èØÔ∏è</button>
          <button data-dir="right">‚û°Ô∏è</button>
          <div class="empty"></div>
          <button data-dir="down">‚¨áÔ∏è</button>
          <div class="empty"></div>
        </div>
      </div>

      <footer>
        Laget i ren HTML/CSS/JS. Ingen rammeverk.
      </footer>
    </aside>
  </div>

  <script>
    (function() {
      const canvas = document.getElementById('board');
      const ctx = canvas.getContext('2d');

      const CELL = 20; // pikselst√∏rrelse per rute
      const COLS = Math.floor(canvas.width / CELL);
      const ROWS = Math.floor(canvas.height / CELL);

      const DIRS = { ArrowLeft: [-1,0], ArrowRight: [1,0], ArrowUp: [0,-1], ArrowDown: [0,1],
                     a: [-1,0], d: [1,0], w: [0,-1], s: [0,1], A: [-1,0], D: [1,0], W: [0,-1], S: [0,1] };

      // UI refs
      const scoreEl = document.getElementById('score');
      const hiEl = document.getElementById('hiscore');
      const speedEl = document.getElementById('speedval');
      const startBtn = document.getElementById('startBtn');
      const pauseBtn = document.getElementById('pauseBtn');
      const resetBtn = document.getElementById('resetBtn');
      const slowerBtn = document.getElementById('slowerBtn');
      const fasterBtn = document.getElementById('fasterBtn');
      const wrapBtn = document.getElementById('wrapBtn');
      const touchPause = document.getElementById('touchPause');

      // Game state
      let snake, dir, nextDir, food, score, hiscore, speed, tickMs, lastTime, acc, running, wrapWalls;

      function init() {
        snake = [ {x: Math.floor(COLS/2), y: Math.floor(ROWS/2)}, {x: Math.floor(COLS/2)-1, y: Math.floor(ROWS/2)}, {x: Math.floor(COLS/2)-2, y: Math.floor(ROWS/2)} ];
        dir = {x:1, y:0};
        nextDir = {...dir};
        food = spawnFood();
        score = 0;
        speed = 1; // multiplier
        tickMs = 140; // base speed (ms per step)
        lastTime = 0; acc = 0; running = false;
        wrapWalls = true; // allow wrapping by default
        hiEl.textContent = hiscore = Number(localStorage.getItem('snake_hi') || 0);
        updateUI();
        draw();
      }

      function spawnFood() {
        let pos;
        do {
          pos = { x: Math.floor(Math.random()*COLS), y: Math.floor(Math.random()*ROWS) };
        } while (snake.some(s => s.x === pos.x && s.y === pos.y));
        return pos;
      }

      function updateUI() {
        scoreEl.textContent = score;
        speedEl.textContent = speed.toFixed(1) + 'x';
        wrapBtn.textContent = 'Vegger: ' + (wrapWalls ? 'P√•' : 'Av');
      }

      function setDir(dx, dy) {
        // forby 180¬∞ snu
        if (dx === -dir.x && dy === -dir.y) return;
        nextDir = {x:dx, y:dy};
      }

      document.addEventListener('keydown', (e) => {
        if (DIRS[e.key]) { const [dx,dy] = DIRS[e.key]; setDir(dx,dy); }
        if (e.code === 'Space') togglePause();
      });

      function togglePause() {
        if (!running) return; // can only pause while running
        running = false;
        draw(true);
      }

      function start() {
        if (running) return;
        running = true;
        lastTime = performance.now();
        acc = 0;
        requestAnimationFrame(loop);
      }

      function reset() { init(); }

      function loop(t) {
        if (!running) return;
        const dt = t - lastTime; lastTime = t; acc += dt;
        const step = Math.max(40, tickMs / speed);
        while (acc >= step) { tick(); acc -= step; }
        draw();
        requestAnimationFrame(loop);
      }

      function tick() {
        dir = nextDir; // apply buffered input once per tick
        const head = { x: snake[0].x + dir.x, y: snake[0].y + dir.y };

        if (wrapWalls) {
          if (head.x < 0) head.x = COLS-1;
          if (head.x >= COLS) head.x = 0;
          if (head.y < 0) head.y = ROWS-1;
          if (head.y >= ROWS) head.y = 0;
        }
        // Collision with walls (when wrap off)
        if (!wrapWalls && (head.x < 0 || head.x >= COLS || head.y < 0 || head.y >= ROWS)) {
          return gameOver();
        }
        // Self collision
        if (snake.some(s => s.x === head.x && s.y === head.y)) {
          return gameOver();
        }
        snake.unshift(head);
        if (head.x === food.x && head.y === food.y) {
          score += 10;
          if (score > hiscore) { hiscore = score; localStorage.setItem('snake_hi', hiscore); hiEl.textContent = hiscore; }
          food = spawnFood();
          // speed up a bit every 30 pts
          if (score % 30 === 0) speed = Math.min(3, speed + 0.1);
        } else {
          snake.pop();
        }
        updateUI();
      }

      function gameOver() {
        running = false;
        draw();
        flashMessage('Game over! Trykk Reset eller Start.');
      }

      function draw(paused=false) {
        // background grid
        ctx.fillStyle = '#0c1224';
        ctx.fillRect(0,0,canvas.width,canvas.height);
        ctx.fillStyle = 'rgba(255,255,255,0.035)';
        for (let y=0; y<ROWS; y++) {
          for (let x=0; x<COLS; x++) {
            if ((x+y)%2===0) ctx.fillRect(x*CELL, y*CELL, CELL, CELL);
          }
        }
        // food
        ctx.fillStyle = '#f59e0b';
        roundedRect(ctx, food.x*CELL+3, food.y*CELL+3, CELL-6, CELL-6, 4);
        ctx.fill();
        // snake
        for (let i=0; i<snake.length; i++) {
          const s = snake[i];
          const alpha = Math.max(0.6, 1 - i*0.03);
          ctx.fillStyle = `rgba(94,234,212,${alpha})`;
          roundedRect(ctx, s.x*CELL+2, s.y*CELL+2, CELL-4, CELL-4, 6);
          ctx.fill();
        }
        if (paused) flashMessage('Pause');
      }

      function roundedRect(ctx, x, y, w, h, r) {
        ctx.beginPath();
        ctx.moveTo(x+r, y);
        ctx.arcTo(x+w, y, x+w, y+h, r);
        ctx.arcTo(x+w, y+h, x, y+h, r);
        ctx.arcTo(x, y+h, x, y, r);
        ctx.arcTo(x, y, x+w, y, r);
        ctx.closePath();
      }

      function flashMessage(text) {
        ctx.save();
        ctx.fillStyle = 'rgba(0,0,0,0.35)';
        ctx.fillRect(0,0,canvas.width,canvas.height);
        ctx.fillStyle = 'white';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.font = '700 28px system-ui';
        ctx.fillText(text, canvas.width/2, canvas.height/2);
        ctx.restore();
      }

      // Buttons & touch
      startBtn.addEventListener('click', () => { if (!running) start(); });
      pauseBtn.addEventListener('click', togglePause);
      resetBtn.addEventListener('click', reset);
      slowerBtn.addEventListener('click', () => { speed = Math.max(0.5, +(speed - 0.1).toFixed(1)); updateUI(); });
      fasterBtn.addEventListener('click', () => { speed = Math.min(3.0, +(speed + 0.1).toFixed(1)); updateUI(); });
      wrapBtn.addEventListener('click', () => { wrapWalls = !wrapWalls; updateUI(); });

      document.querySelectorAll('[data-dir]').forEach(btn => {
        btn.addEventListener('click', () => {
          const d = btn.getAttribute('data-dir');
          if (d === 'up') setDir(0,-1); else if (d==='down') setDir(0,1); else if (d==='left') setDir(-1,0); else if (d==='right') setDir(1,0);
        });
      });
      touchPause.addEventListener('click', () => { running ? togglePause() : start(); });

      // Start opp
      init();
    })();
  </script>
</body>
</html>
